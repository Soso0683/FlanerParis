{% comment %}
  Section : Carrousel de vidéos (upload, auto-avance à la fin, swipe, infini)
  Fichier : sections/videos-carousel.liquid
{% endcomment %}

<section id="vids-{{ section.id }}" class="vidsec">
  {% if section.settings.heading != blank %}
    <h2 class="vidsec__title">{{ section.settings.heading }}</h2>
  {% endif %}

  <div class="vidsec__viewport">
    <button class="vidsec__btn vidsec__btn--prev" aria-label="Précédent" type="button">‹</button>

    <div class="vidsec__track">
      {%- for block in section.blocks -%}
        <div class="vidsec__item" {{ block.shopify_attributes }}>
          {% if block.settings.video != blank %}
            {{ block.settings.video
              | video_tag:
                class: 'vidsec__video',
                autoplay: true,
                muted: true,
                loop: false,
                playsinline: true,
                controls: false,
                preload: 'auto'
            }}
          {% elsif block.settings.mp4_url != blank %}
            <video class="vidsec__video"
                   src="{{ block.settings.mp4_url }}"
                   autoplay muted playsinline preload="auto"></video>
          {% else %}
            <div class="vidsec__placeholder">Video fehlt</div>
          {% endif %}
        </div>
      {%- endfor -%}
    </div>

    <button class="vidsec__btn vidsec__btn--next" aria-label="Suivant" type="button">›</button>
  </div>
</section>

<style>
  #vids-{{ section.id }}.vidsec{ --gap:16px; --radius:16px; color:#111; font-family:inherit }
  #vids-{{ section.id }} .vidsec__title{ margin:0 0 14px; text-align:center }

  #vids-{{ section.id }} .vidsec__viewport{ position:relative; overflow:hidden; width:100% }
  #vids-{{ section.id }} .vidsec__track{
    --visible:3; /* desktop par défaut */
    display:flex; gap:var(--gap); align-items:stretch;
    transition:transform .5s ease; will-change:transform;
  }
  /* 3 visibles desktop, 2 visibles mobile */
  #vids-{{ section.id }} .vidsec__item{
    flex:0 0 calc((100% - (var(--gap) * (var(--visible) - 1))) / var(--visible));
    border-radius:var(--radius); overflow:hidden; background:#000;
  }
  #vids-{{ section.id }} .vidsec__video{
    width:100%; height:100%; display:block; object-fit:cover;
    pointer-events:none; /* pas cliquable */
  }
  #vids-{{ section.id }} .vidsec__placeholder{
    height:220px; display:grid; place-items:center; color:#888; background:#f1f1f1
  }
  #vids-{{ section.id }} .vidsec__btn{
    position:absolute; top:50%; transform:translateY(-50%);
    width:36px; height:36px; border-radius:50%; border:none;
    background:#111; color:#fff; opacity:.92; display:grid; place-items:center;
    cursor:pointer; z-index:2;
  }
  #vids-{{ section.id }} .vidsec__btn--prev{ left:6px }
  #vids-{{ section.id }} .vidsec__btn--next{ right:6px }

  @media (max-width: 768px){
    #vids-{{ section.id }} .vidsec__track{ --visible:2; }
    #vids-{{ section.id }} .vidsec__btn{ width:32px; height:32px }
  }
</style>

<script>
(function(){
  const root  = document.getElementById('vids-{{ section.id }}'); if(!root) return;
  const track = root.querySelector('.vidsec__track');
  const prevB = root.querySelector('.vidsec__btn--prev');
  const nextB = root.querySelector('.vidsec__btn--next');
  let items   = Array.from(track.children);
  const orig  = items.length;
  if (orig === 0) return;

  const getVisible = () => parseInt(getComputedStyle(track).getPropertyValue('--visible')) || 3;
  const getStep = () => {
    const cardW = items[0].getBoundingClientRect().width;
    const gap   = parseFloat(getComputedStyle(track).gap) || 0;
    return cardW + gap;
  };

  // Clones pour boucle infinie
  let cloneN = Math.min(getVisible(), orig);
  // fin -> début
  for(let i=orig-cloneN; i<orig; i++){ track.insertBefore(items[i].cloneNode(true), track.firstChild); }
  // début -> fin
  for(let i=0; i<cloneN; i++){ track.appendChild(items[i].cloneNode(true)); }
  items = Array.from(track.children);

  let index = cloneN;     // commence sur le 1er vrai
  let step  = getStep();

  const go = (to, animate=true) => {
    index = to;
    track.style.transition = animate ? 'transform .5s ease' : 'none';
    track.style.transform  = `translateX(${-index * step}px)`;
    // (re)lancer les vidéos visibles
    playVisible();
  };

  // Réglage quand on traverse un clone
  track.addEventListener('transitionend', () => {
    if (index >= orig + cloneN){ go(index - orig, false); }
    else if (index < cloneN){    go(index + orig, false); }
  });

  // Boutons
  nextB.addEventListener('click', ()=> go(index + 1, true));
  prevB.addEventListener('click', ()=> go(index - 1, true));

  // Resize
  const ro = new ResizeObserver(()=>{ step = getStep(); go(index, false); });
  ro.observe(root);

  // Swipe
  const vp = root.querySelector('.vidsec__viewport');
  let startX=0, delta=0, dragging=false;
  const start = x => { dragging=true; startX=x; delta=0; track.style.transition='none'; };
  const move  = x => { if(!dragging) return; delta=x-startX; track.style.transform=`translateX(${-(index*step)+delta}px)`; };
  const end   = () => {
    if(!dragging) return; dragging=false;
    const thr = Math.max(40, step*0.18);
    if (delta >  thr) go(index-1, true);
    else if (delta < -thr) go(index+1, true);
    else go(index, true);
  };
  vp.addEventListener('pointerdown', e=>{ vp.setPointerCapture(e.pointerId); start(e.clientX); });
  vp.addEventListener('pointermove', e=> move(e.clientX));
  vp.addEventListener('pointerup', end);
  vp.addEventListener('pointercancel', end);
  vp.addEventListener('touchstart', e=> start(e.touches[0].clientX), {passive:true});
  vp.addEventListener('touchmove',  e=> move(e.touches[0].clientX), {passive:true});
  vp.addEventListener('touchend', end);

  // Lecture auto des vidéos visibles + auto-avance quand une vidéo visible se termine
  const vids = Array.from(root.querySelectorAll('video'));
  let advancing = false;
  const safeNext = () => {
    if (advancing) return;
    advancing = true;
    go(index + 1, true);
    setTimeout(()=> advancing = false, 400);
  };

  // Jouer/Pause en fonction de la visibilité
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const v = entry.target;
      if (entry.isIntersecting && entry.intersectionRatio > 0.55){
        try { if (v.paused) { v.currentTime = 0; v.play().catch(()=>{}); } } catch(e){}
        // écoute 'ended' uniquement quand bien visible
        v.onended = safeNext;
      } else {
        try { v.pause(); } catch(e){}
        v.onended = null;
      }
    });
  }, { root: vp, threshold: [0, .55, 1] });

  vids.forEach(v=>{
    // s'assurer que l'autoplay redémarre quand on revient sur l'onglet
    const tryPlay = ()=> v.play().catch(()=>{});
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) tryPlay(); });
    io.observe(v);
  });

  // Position initiale
  go(index, false);
})();
</script>

{% schema %}
{
  "name": "Carrousel vidéos (upload)",
  "settings": [
    { "type": "text", "id": "heading", "label": "Titre", "default": "Des résultats concrets" }
  ],
  "blocks": [
    {
      "type": "clip",
      "name": "Vidéo",
      "settings": [
        { "type": "video", "id": "video", "label": "Vidéo (téléversée sur Shopify)" },
        { "type": "url", "id": "mp4_url", "label": "OU URL .mp4 (fallback)" }
      ]
    }
  ],
  "max_blocks": 12,
  "presets": [
    { "name": "Vidéos (défilement infini)", "blocks": [{ "type": "clip" }, { "type": "clip" }, { "type": "clip" }, { "type": "clip" }] }
  ]
}
{% endschema %}
